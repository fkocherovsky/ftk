{"version":3,"file":"config.js","sourceRoot":"","sources":["../../../../../gserver/src/core/config.ts"],"names":[],"mappings":"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","sourcesContent":["// import * as Fs from 'fs';\r\nimport * as Fsp from 'fs/promises';\r\n// import * as Inspector from 'inspector';\r\nimport { Index, isString, isArray, GError, isBoolean, isNumber, logE, logI, Gmap } from '../../../kit/src/core';\r\n// import * as Os from 'os';\r\nimport * as Path from 'path';\r\n\r\nimport { appName } from './bootstrap';\r\nimport { ServiceParamTypeName, schemaParseTypedValue } from './schema';\r\n\r\nimport 'reflect-metadata';\r\n\r\n\r\nexport class ConfigMetadata {\r\n    description?: string;\r\n    encrypted?: boolean;\r\n    notify?: boolean;\r\n    dataType?: ServiceParamTypeName;\r\n    configOnly?: boolean; // a flag saying if a property is only set by config file, and can't be updated from DB\r\n}\r\nlet _configMetadataKey = Symbol('ConfigMetadata');\r\n \r\nexport function configurable(metadata?: ConfigMetadata) {\r\n    if (!metadata) { metadata = new ConfigMetadata(); }\r\n    return Reflect.metadata(_configMetadataKey, metadata);\r\n}\r\n\r\nexport function cfgGetMetadata(o: any, property?: string) {\r\n    return Reflect.getMetadata(_configMetadataKey, o, property) as ConfigMetadata;\r\n}\r\n\r\n\r\nexport const G_SERVER_FOLDER_NAME = 'gserver';\r\n\r\nexport let cfgDeploymentRoot: string   // <deployment-root>\r\nexport let cfgCoreEtcRoot: string;     // <deployment-root>/gserver/etc (local)\r\nexport let cfgAppEtcRoot: string;      // <deployment-root>/<app-server>/etc\r\nexport let cfgServerBinRoot: string;\r\nexport let cfgAppSrcRoot: string;\r\nexport let configCoreSrcRoot: string;  // <deployment-root>/<app-server>/bin/gserver/src\r\n\r\nexport class StartupFlags {\r\n    app: string;\r\n    env: string;\r\n    [key: string]: string | number | boolean;\r\n}\r\n \r\n\r\nexport async function cfgInitialize() {\r\n    let coreConfigJsPath = module.filename;\r\n    cfgDeploymentRoot = Path.resolve(coreConfigJsPath, '../../../../../../');\r\n    let serverRoot = Path.resolve(coreConfigJsPath, '../../../../../');\r\n    cfgServerBinRoot = Path.resolve(coreConfigJsPath, '../../../../');\r\n    let bootstrapJsPath = require.main.filename;\r\n    cfgAppSrcRoot = Path.dirname(bootstrapJsPath); \r\n    configCoreSrcRoot    = Path.resolve(coreConfigJsPath, './../../');             // [<deployment-root>/<server-root>/bin/gserver/src] /core/config.js \r\n\r\n    cfgCoreEtcRoot = Path.join(cfgDeploymentRoot, G_SERVER_FOLDER_NAME, 'etc');\r\n    cfgAppEtcRoot = Path.join(serverRoot, 'etc');\r\n\r\n}\r\n\r\nexport async function cfgApply() {\r\n    let sFlags = cfgGetStartupFlags();\r\n    let fileConfig: Map<string, any> = new Map();\r\n    let defaultConfigFile = Path.join(cfgAppEtcRoot, 'settings', `${appName}.properties`);\r\n    let envConfigFile = Path.join(cfgAppEtcRoot, 'settings', `${appName}.(${sFlags.env}).properties`);\r\n    fileConfig = await _loadProperties(defaultConfigFile);\r\n    fileConfig = new Map([...fileConfig, ...(await _loadProperties(envConfigFile))]);\r\n\r\n    for (let [key, value] of fileConfig.entries()) {\r\n        let values = key.split(/[\\[\\]]/);\r\n        if (values.length >= 2) {\r\n           try {\r\n              fileConfig.delete(key);\r\n              key = values[0];\r\n              let otherkey = values[1].trim();\r\n              let othervalue = otherkey.startsWith('@') ? fileConfig.get(otherkey.substring(1)) : otherkey;\r\n              if (!othervalue) { logE(`Referenced key '${key}[${otherkey}]' value is empty, config entry skipped`); continue; }\r\n  \r\n              let o = fileConfig.get(key);\r\n              if (!o) {\r\n                 fileConfig.set(key, {});\r\n              } else if (isString(o)) {\r\n                 fileConfig.set(key, {}); // this handles the case when entire map is defined in config property (i.e. when \"key = { xxx }\" is used instead of \"key[xxx]\")\r\n              }\r\n              let map = fileConfig.get(key) as Gmap;\r\n              if (map[othervalue] !== undefined) { throw \"new GError(`Duplicate map value for key ${othervalue}`)\"; }\r\n              map[othervalue] = value;\r\n              logI(`${othervalue} : ${value}`);\r\n            } catch (e) {\r\n              throw \"new GError(`Invalid map property value: ${key}`, e)\";\r\n            }\r\n        }\r\n    }\r\n\r\n    for (let [key, cd] of Object.entries(_configuration)) {\r\n        if (!cd.configMetadata.encrypted && (cd.dataType == 'string' || cd.dataType == 'string[]') && (/.*(password|appkey|apikey|secret).*/i.test(key))) {\r\n            throw new GError(`${key}: secrets must be marked as encrypted = true`);\r\n        }\r\n        let value = fileConfig.get(key);\r\n        if (value === undefined) { continue; }\r\n\r\n        fileConfig.delete(key);\r\n        value = schemaParseTypedValue(cd.dataType, value);\r\n        // TODO: add proper value parsing\r\n        cd.value = value;\r\n        // TODO: handle encrypted config\r\n        // if (cd.configMetadata.encrypted) { value = cryptoIsInitialized ? _decrypt(value) : value; }\r\n        if (cd.configMetadata.encrypted) { \r\n            value = _decrypt(value);\r\n        }\r\n        Reflect.set(cd.configObject, cd.configProperty, value);\r\n    }\r\n    logI('config applied');\r\n}\r\n\r\nfunction _decrypt(str: string) {\r\n    return `DummyDecrypted_${str}`;\r\n }\r\n \r\n\r\nexport function cfgGetStartupFlags(): StartupFlags {\r\n    let args = process.argv.slice(2);\r\n    let flags: StartupFlags = new StartupFlags();\r\n    for (let i = 0, len = args.length; i < len; i += 2) {\r\n       let value = args[i + 1];\r\n       flags[args[i].replace(/^-+/, '')] = (value.match(/^[0-9]+$/) || value.match(/^true|false$/)) ? JSON.parse(value) : value;\r\n    }\r\n    return flags;\r\n}\r\n\r\nexport function cfgLoadMetadata(fpath: string, configModule: any, configObject: any, configMetadata: ConfigMetadata) {\r\n    if (configMetadata.notify || configMetadata.encrypted || configMetadata.dataType) { throw \"new GError(`'notify', 'encrypted', 'dataType' config metadata values can only be set on properties`)\"; }\r\n \r\n    let relativePath = fpath.substr(cfgAppSrcRoot.length + 1);\r\n    let configObjectPath = relativePath.replace(/\\/|\\\\/g, '.').replace(/\\.js$/i, '');\r\n    for (let [pname, pvalue] of Object.entries(configObject)) {\r\n       let pmd = cfgGetMetadata(configObject, pname) || new ConfigMetadata();\r\n       let configPath = `${configObjectPath}.${pname}`;\r\n       // let configReloader = configModule['onConfigReloaded'] as StartupFunction;\r\n       // let configAppnames = configReloader?.metadata.appnames;\r\n       // if (configReloader && configAppnames && configAppnames != '*' && !configAppnames.includes(appName)) { configReloader = null; }\r\n       let cd: ConfigDescriptor = {\r\n          configPath: configPath,\r\n          configObject: configObject,\r\n          configModule: configModule,\r\n          configProperty: pname,\r\n          configMetadata: pmd,\r\n          // configReloader: pmd.notify ? configReloader : null,\r\n          configOnly: pmd.configOnly,\r\n          defaultValue: pvalue,\r\n          dataType: pmd.dataType || _getConfigDataType(pvalue),\r\n          value: pvalue,\r\n          updatedOn: null // DateTime.now().toISO()\r\n       };\r\n       _configuration[configPath] = cd;\r\n    }\r\n}\r\n\r\n\r\n/***************************************/\r\nasync function _loadProperties(path: string) {\r\n    if (path == null) { return null; }\r\n \r\n    let props: Map<string, any> = new Map();\r\n    let file = await Fsp.readFile(path, 'utf8');\r\n    let lines = file.split(/[\\r\\n]+/);\r\n    for (let s of lines) {\r\n       s = s.trim();\r\n       if (s.length == 0 || s.charAt(0) == '#') { continue; }\r\n \r\n       let i = s.indexOf('=');\r\n       if (i <= 0) { continue; }\r\n \r\n       // remove all spaces around the key (e.g. key can be Gmap in which [] brackets are vertically aligned using spaces)\r\n       let key = s.substring(0, i).trim();\r\n \r\n       // we guess JSON/array values (99% of usages) - if anyone wants to keep string - use quotes\r\n       let value = null;\r\n       s = s.substring(i + 1).trim();\r\n       if (s.charAt(0) == '{' && s.charAt(s.length - 1) == '}') {\r\n          value = JSON.parse(s);\r\n       } else if (s.charAt(0) == '[' && s.charAt(s.length - 1) == ']') {\r\n          value = JSON.parse(s);\r\n       } else {\r\n          value = s.replace(/(^\")|(\"$)/g, '');\r\n       }\r\n \r\n       if (props.has(key)) { logE(`Duplicate key ${key} in file: ${path}`); }\r\n       props.set(key, value);\r\n    }\r\n    return props;\r\n}\r\n\r\ninterface ConfigDescriptor {\r\n    configPath: string;\r\n    configObject: object;\r\n    configModule: object;\r\n    configProperty: string;\r\n    configMetadata: ConfigMetadata;\r\n    // configReloader?: StartupFunction; // async function on configModule which is called when this property is changed\r\n    configOnly?: boolean;\r\n    defaultValue: any;\r\n    dataType: ServiceParamTypeName;\r\n    value: any;\r\n    updatedOn: string;\r\n }\r\n \r\n\r\n\r\n\r\nfunction _getConfigDataType(value: any, ignoreArrays?: boolean): ServiceParamTypeName {\r\n    if (value == null) {\r\n       return 'object';\r\n    } else if (isString(value)) {\r\n       return 'string';\r\n    } else if (isBoolean(value)) {\r\n       return 'boolean';\r\n    } else if (isNumber(value)) {\r\n       return 'number';\r\n    } else if (!ignoreArrays && isArray(value)) {\r\n       return _getConfigDataType(value[0], true) + '[]' as ServiceParamTypeName; // for arrays - drill-down take first item's type, but don't go deeper than 1st level (deeper-then-top-level config values are always JSON objects)\r\n    } else {\r\n       return 'object';\r\n    }\r\n }\r\n \r\n \r\nlet _configuration: Index<ConfigDescriptor> = {}; \r\n "]}