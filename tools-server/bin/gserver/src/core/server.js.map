{"version":3,"file":"server.js","sourceRoot":"","sources":["../../../../../gserver/src/core/server.ts"],"names":[],"mappings":";;;;;;;;;AAAA,6BAA6B;AAC7B,2BAA2B;AAE3B,gDAAqE;AAErE,qCAAiE;AACjE,qCAA0F;AAC1F,qCAAkE;AAClE,uCAAoF;AACpF,qCAAkD;AAClD,2DAA4D;AAE5D,+BAAqC;AAI1B,QAAA,aAAa,GAAG,KAAK,CAAC;AACtB,QAAA,cAAc,GAA6B,EAAE,CAAC;AAGlD,IAAM,QAAQ,GAAd,MAAM,QAAQ;;AACX,mBAAU,GAAG,aAAa,CAAC;AADxB,QAAQ;IADpB,IAAA,qBAAY,GAAE;GACF,QAAQ,CAEpB;AAFY,4BAAQ;AAKd,KAAK,UAAU,gBAAgB;IAClC,IAAI;QACA,MAAM,IAAA,sBAAa,GAAE,CAAC;QACtB,MAAM,IAAA,0BAAiB,GAAE,CAAC;QAC1B,MAAM,aAAa,EAAE,CAAC;QACtB,MAAM,IAAA,iBAAQ,GAAE,CAAC;QACjB,IAAI,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,EAAE,SAAS,EAAE,IAAI,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE;YACnE,MAAM,kBAAkB,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;QACvC,CAAC,CAAC,CAAC;QACH,MAAM,CAAC,OAAO,GAAG,KAAK,CAAC;QACvB,MAAM,CAAC,gBAAgB,GAAG,OAAO,CAAC;QAClC,MAAM,CAAC,MAAM,CAAC,EAAE,CAAkB,CAAC;KACtC;IAAC,OAAO,CAAC,EAAE;QACR,IAAA,YAAK,EAAC,CAAC,CAAC,CAAC;KACZ;AAEL,CAAC;AAhBD,4CAgBC;AAED,IAAI,aAAa,GAAG,gBAAgB,CAAC;AACrC,KAAK,UAAU,kBAAkB,CAAC,GAAyB,EAAE,GAAwB;IACjF,IAAI,OAA2B,CAAC;IAChC,IAAI;QACA,IAAI,UAAU,GAAG,QAAQ,CAAC,UAAU,CAAC;QACrC,IAAI,GAAG,GAAG,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QACnC,IAAI,OAAO,GAAG,GAAG,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC;QAQzC,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;QACvE,IAAI,EAAE,GAAQ,sBAAc,CAAC,OAAO,CAAC,CAAC;QACtC,IAAI,EAAE,IAAI,IAAI,EAAE;YAAE,MAAM,aAAM,CAAC,SAAS,EAAE,CAAC;SAAE;QAC7C,IAAI,CAAC,EAAE,CAAC,SAAS,EAAE;YAAE,MAAM,aAAM,CAAC,SAAS,CAAC,4CAA4C,EAAE,CAAC,aAAa,IAAI,MAAM,CAAC,CAAC,CAAC,mGAAmG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;SAAE;QAEnO,IAAI,EAAE,CAAC,QAAQ,IAAI,aAAa,IAAI,EAAE,CAAC,QAAQ,IAAI,eAAe,EAAE;YAChE,MAAM,aAAM,CAAC,aAAa,CAAC,GAAG,EAAE,CAAC,QAAQ,sBAAsB,CAAC,CAAC;SACpE;aAAM;YAEH,OAAO,GAAG,cAAc,CAAC,4BAAkB,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAe,IAAI,EAA4B,IAAI,CAAC,CAAC;SACtH;QAED,OAAO,CAAC,QAAQ,EAAE,CAAC;QACnB,MAAM,OAAO,CAAC,IAAI,EAAE,CAAC;QACrB,MAAM,cAAc,CAAC,OAAO,CAAC,CAAC;KACjC;IAAC,OAAO,CAAC,EAAE;QAER,IAAA,mBAAU,EAAC,CAAC,EAAE,OAAO,EAAE,0BAA0B,CAAC,CAAC;KACtD;AACL,CAAC;AAED,KAAK,UAAU,cAAc,CAAC,OAAwB;IAClD,IAAI;QACA,IAAA,mBAAU,EAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC1B,IAAI,SAAgB,CAAC;QACrB,IAAI,MAA2B,CAAC;QAChC,IAAI;YACA,IAAI,MAAM,GAAG,OAAO,CAAC,SAAS,EAAE,CAAC;YACjC,MAAM,2BAA2B,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;YACnD,IAAI,KAAK,GAAG,MAAM,OAAO,CAAC,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,OAAO,EAAE,IAAI,EAAE,CAAC,MAAM,EAAE,OAAO,CAAC,CAA4B,CAAC;YACxG,IAAI,KAAK,KAAK,KAAK,EAAE;gBAAE,MAAM,aAAM,CAAC,iBAAiB,EAAE,CAAC;aAAE;YAC1D,MAAM,GAAG,CAAC,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAA4B,CAAC;SAC5G;QAAC,OAAO,CAAC,EAAE;YACR,SAAS,GAAG,CAAC,CAAC;YACd,IAAA,mBAAU,EAAC,CAAC,EAAE,OAAO,CAAC,CAAC;SAC1B;QAED,IAAI,IAAI,GAAG,OAAO,CAAC,cAAc,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;QACrD,MAAM,IAAA,kBAAY,EAAC,IAAI,EAAE,SAAS,EAAE,OAAO,CAAC,CAAC;KAChD;IAAC,OAAO,CAAC,EAAE;QAGR,IAAA,YAAK,EAAC,CAAC,EAAE,4BAA4B,OAAO,CAAC,gBAAgB,EAAE,CAAC,CAAC;KACpE;AACL,CAAC;AAED,KAAK,UAAU,2BAA2B,CAAC,OAAwB,EAAE,KAAoB;AAEzF,CAAC;AAED,SAAS,aAAa;IAClB,KAAK,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,8BAAqB,CAAC,EAAE;QAChE,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC,WAAW,EAAE,CAAC;QACjD,sBAAc,CAAC,GAAG,CAAC,GAAG,IAAI,0BAAiB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;KAC5D;AACL,CAAC;AAED,SAAS,cAAc,CAA4B,IAAsB,EAAE,GAAG,IAAW;IACtF,OAAO,IAAA,qBAAW,EAAC,6BAAoB,CAAC,GAAG,CAAC,IAAI,CAAqB,EAAE,GAAG,IAAI,CAAC,CAAC;AACnF,CAAC","sourcesContent":["import * as Http from 'http';\r\nimport * as Url from 'url';\r\n\r\nimport { GError, Gvalue, Index, logEx } from '../../../kit/src/core';\r\n\r\nimport { cfgApply, cfgInitialize, configurable } from './config';\r\nimport { loaderContextClasses, loaderScanModules, loaderServiceHandlers } from './loader';\r\nimport { ServiceDescriptor, ServiceResponseType } from './schema';\r\nimport { BasicServerContext, AServiceContext, HttpServiceContext } from './context';\r\nimport { logFailure, logTraffic } from './logger';\r\nimport { instantiate } from '../../../kit/src/core/reflect';\r\nimport { Garray, Gmap } from '../../../kit/src/core/types';\r\nimport { webServeData } from './web';\r\n\r\n// import { Index, isString, isArray, isBoolean, isNumber, logE, logI, Gmap } from '../../../kit/src/core';\r\n\r\nexport let inDevelopment = false;\r\nexport let serverServices: Index<ServiceDescriptor> = {}; // keys are a lowercase path just after Settings.serverRoot (e.g. internal/testing/servicename, or services/testing/servicename)\r\n\r\n@configurable()\r\nexport class Settings {\r\n   static serverRoot = '/gmlserver/';\r\n}\r\n\r\n\r\nexport async function initializeServer() {\r\n    try {\r\n        await cfgInitialize();\r\n        await loaderScanModules();\r\n        await _loadServices();\r\n        await cfgApply();\r\n        let server = Http.createServer({ keepAlive: true }, async (req, res) => {\r\n            await _handleHttpRequest(req, res);\r\n        });\r\n        server.timeout = 30000; //WebSettings.defaultRequestTimeout;\r\n        server.keepAliveTimeout = 1800000; //WebSettings.inboundKeepAliveTimeout; // default must be overriden and set to more than what's set in inbound router/reverse-proxy\r\n        server.listen(80/*Settings.port*/);\r\n    } catch (e) {\r\n        logEx(e);\r\n    }\r\n\r\n}\r\n\r\nlet tmpServerRoot = '/tools-server/'; // TODO: replace by Settings.serverRoot\r\nasync function _handleHttpRequest(req: Http.IncomingMessage, res: Http.ServerResponse) {\r\n    let context: HttpServiceContext;\r\n    try {\r\n        let serverRoot = Settings.serverRoot;\r\n        let url = Url.parse(req.url, true);\r\n        let pathlow = url.pathname.toLowerCase();\r\n        //    TODO: \r\n        // // handle non-service (web file) requests\r\n        // if (!pathlow.startsWith(serverRoot)) { return await webServeFile(new BasicHttpContext(req, res)); }\r\n\r\n        // TODO: meanwhile alias == url. to implement real alias mechanism\r\n        // let aliasurl: Url.UrlWithParsedQuery = url;\r\n\r\n        pathlow = pathlow.substr(tmpServerRoot.length).replace(/\\.[^.]*$/, ''); // remove extension from path, if any\r\n        let sd: any = serverServices[pathlow];\r\n        if (sd == null) { throw GError.NOT_FOUND(); }\r\n        if (!sd.isExposed) { throw GError.NOT_FOUND(`not exposed by schema, or not whitelisted${sd.authorization == 'none' ? `(note that authorization = 'none' services require whitelisting by full name, not by namespace.*)` : ''}`); }\r\n    \r\n        if (sd.protocol == 'http-upload' || sd.protocol == 'http-download') {\r\n            throw GError.NOT_SUPPORTED(`${sd.protocol} isnot supported yet`);\r\n        } else {\r\n            //constructor(req: Http.IncomingMessage, res: Http.ServerResponse, sd: ServiceDescriptor, url: Url.UrlWithParsedQuery, aliasurl?: Url.UrlWithParsedQuery, aliasparams?: Qs.ParsedUrlQuery) {\r\n            context = _createContext(HttpServiceContext, req, res, sd, url, /*aliasurl*/ null, /*aliasdata.aliasparams*/ null);\r\n        }\r\n\r\n        context.validate();\r\n        await context.seal();\r\n        await _handleService(context);\r\n    } catch (e) {\r\n        // TODO: detailed exception handling \r\n        logFailure(e, context, 'failed to handle request');\r\n    }\r\n}\r\n\r\nasync function _handleService(context: AServiceContext) {\r\n    try {\r\n        logTraffic('IN', context);\r\n        let exception: Error;\r\n        let result: ServiceResponseType;\r\n        try {\r\n            let params = context.getParams();\r\n            await _validateServicePermissions(context, params);\r\n            let value = await Reflect.apply(context.sd.handler, null, [params, context]) as Garray | Gmap | boolean; // TODO: add Gxml after the type implementing\r\n            if (value === false) { throw GError.APPLICATION_ERROR(); } // service returning false wants to respond with generic applicative error\r\n            result = (value === true || value === null || value === undefined) ? null : value as ServiceResponseType;\r\n        } catch (e) {\r\n            exception = e;\r\n            logFailure(e, context);\r\n        }\r\n\r\n        let data = context.formatResponse(result, exception);\r\n        await webServeData(data, exception, context);\r\n    } catch (e) {\r\n        // TODO: detailed exception handling \r\n        // logFailure(e, context, 'failed to handle request');\r\n        logEx(e, `failed to handle service ${context.loggablePathname}`);\r\n    }\r\n}\r\n\r\nasync function _validateServicePermissions(context: AServiceContext, input: Index<Gvalue>) {\r\n    // TODO: to implement\r\n}\r\n\r\nfunction _loadServices() {\r\n    for (let [name, handler] of Object.entries(loaderServiceHandlers)) {\r\n       let key = name.replace(/\\./g, '/').toLowerCase();\r\n       serverServices[key] = new ServiceDescriptor(name, handler);\r\n     }\r\n }\r\n\r\n function _createContext<T extends AServiceContext>(type: ConstructorOf<T>, ...args: any[]): T {\r\n    return instantiate(loaderContextClasses.get(type) as ConstructorOf<T>, ...args);\r\n }\r\n \r\n "]}