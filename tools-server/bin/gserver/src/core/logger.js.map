{"version":3,"file":"logger.js","sourceRoot":"","sources":["../../../../../gserver/src/core/logger.ts"],"names":[],"mappings":";;;AAGA,SAAgB,kBAAkB;IAE9B,IAAI,EAAE,aAAa,IAAI,YAAY,EAAE;QAAE,aAAa,GAAG,YAAY,CAAC;KAAE;IACtE,OAAO,aAAa,CAAC;AACxB,CAAC;AAJF,gDAIE;AACD,IAAI,YAAY,GAAG,OAAO,CAAC;AAC3B,IAAI,YAAY,GAAG,OAAO,CAAC;AAC3B,IAAI,aAAa,GAAG,YAAY,CAAC;AAOlC,SAAgB,IAAI,CAAC,CAAS;IAC1B,IAAI,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;AACjB,CAAC;AAFD,oBAEC;AAED,SAAgB,IAAI,CAAC,CAAS;IAC1B,IAAI,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;AACjB,CAAC;AAFD,oBAEC;AAED,SAAgB,KAAK,CAAC,EAAS,EAAE,OAAgB;IAC7C,IAAI,CAAC,GAAG,gBAAgB,CAAC,EAAE,CAAC,CAAC;IAC7B,IAAI,OAAO,EAAE;QAAE,CAAC,GAAG,GAAG,OAAO,KAAK,CAAC,EAAE,CAAC;KAAE;IACxC,IAAI,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;AACjB,CAAC;AAJD,sBAIC;AAWD,SAAgB,UAAU,CAAC,GAAiB,EAAE,OAAuB,EAAE,IAAU;IAC7E,IAAI,CAAC,SAAS,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,IAAI,OAAO,CAAC,GAAG,IAAI,OAAO,CAAC,gBAAgB,IAAI,OAAO,CAAC,cAAc,IAAI,IAAI,EAAE,CAAC,CAAC;AAChH,CAAC;AAFD,gCAEC;AAED,SAAgB,UAAU,CAAC,SAAgB,EAAE,OAAuB,EAAE,IAAU;IAC5E,IAAI,EAAE,GAAG,gBAAgB,CAAC,SAAS,CAAC,CAAC;IACrC,IAAI,CAAC,SAAS,OAAO,CAAC,GAAG,IAAI,OAAO,CAAC,gBAAgB,IAAI,OAAO,CAAC,cAAc,IAAI,IAAI,KAAK,EAAE,EAAE,CAAC,CAAC;AACtG,CAAC;AAHD,gCAGC;AAGD,SAAS,gBAAgB,CAAC,SAAgB;IACtC,IAAI,KAAK,GAAG,SAAS,EAAE,KAAK,CAAC;IAC7B,IAAI,KAAK,IAAI,SAAS,YAAY,cAAc,IAAI,SAAS,CAAC,MAAM,EAAE,MAAM,GAAG,CAAC,EAAE;QAM/E,KAAK,GAAG,QAAQ,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,KAAK,SAAS,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,iBAAiB,GAAG,KAAK,CAAC;KACvG;IACD,OAAO,KAAK,IAAI,mBAAmB,SAAS,EAAE,OAAO,GAAG,CAAC;AAC7D,CAAC;AAED,SAAS,IAAI,CAAC,CAAS,EAAE,QAAgB;IACrC,IAAI,GAAG,GAAG,IAAI,IAAI,EAAE,CAAA;IACpB,IAAI,EAAE,GAAG,GAAG,GAAG,CAAC,WAAW,EAAE,KAAK,QAAQ,OAAO,CAAC,EAAE,CAAC;IACrD,IAAI,QAAQ,IAAI,GAAG,EAAE;QACjB,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;KACrB;SAAM;QACH,OAAO,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;KACpB;AACL,CAAC","sourcesContent":["import { AServerContext } from \"./context\";\r\n\r\n/** generates server-specific cyclic sequence number */\r\nexport function logGetNextSequence() {\r\n    // TODO: see how to make sequence node-dependent, so each server node will have different sequences range\r\n    if (++_lastSequence >= _maxSequence) { _lastSequence = _minSequence; }\r\n    return _lastSequence;\r\n }\r\n let _minSequence = 1000000;\r\n let _maxSequence = 9999999;\r\n let _lastSequence = _minSequence;\r\n \r\n\r\nexport type LogArguments = [message: string] | [obj: any] | [format: string, ...args: any[]];\r\n\r\n// export function logI(...args: LogArguments)\r\n\r\nexport function logI(s: string){\r\n    _log(s, 'I');\r\n}\r\n\r\nexport function logE(s: string){\r\n    _log(s, 'E');\r\n}\r\n\r\nexport function logEx(ex: Error, details?: string){\r\n    let s = _formatException(ex);\r\n    if (details) { s = `${details}. ${s}`; }\r\n    _log(s, 'E');\r\n}\r\n\r\nexport type LogDirection = 'IN'                         | // incoming request (inbound service call)\r\n                           'OUT'                        | // outgoing response (service call response)\r\n                           'OUT(err)'                   | // outgoing service failure\r\n                           'OUT(timedout)'              | // timeout before service completed\r\n                           'OUT(err)(timedout)'         | // service failed after timeout expired\r\n                           'FW'                         | // forward to external HTTP(s) service\r\n                           'RE'                         | // reply from external HTTP(s) service\r\n                           'DB';                          // internal DB logging\r\n\r\nexport function logTraffic(dir: LogDirection, context: AServerContext, data?: any): void {\r\n    logI(`|Comm|${dir.padEnd(8)}|${context.seq}|${context.loggablePathname}|${context.loggableParams}|${data}`);\r\n}\r\n\r\nexport function logFailure(exception: Error, context: AServerContext, data?: any): void {\r\n    let ex = _formatException(exception);\r\n    logE(`|Comm|${context.seq}|${context.loggablePathname}|${context.loggableParams}|${data}. ${ex}`);\r\n}\r\n\r\n\r\nfunction _formatException(exception: Error) {\r\n    let stack = exception?.stack;\r\n    if (stack && exception instanceof AggregateError && exception.errors?.length > 0) {\r\n       // NOTE:\r\n       // Special case: es2021 introduces AggregateError, and Node.js seeems to throw these a lot for I/O/networking operations with multiple attempts. Inner errors contain a separate error about each connect attempt, about each network interface which was tried, etc., e.g. IPv4, IPv6.\r\n       // The AggregateError's stack itself doesn't have any meaningful message (and top of stack is 'AggregateError' with no details). The below attempts to prefix the stack with first error's message (e.g. ECONNREFUSED...), making it all more descriptive.\r\n       // A more complete solution would be to dump all inner errors with their stacks, but since we're not so interested in Node.js internal stacks anyway, and our code never really uses AggregateError - there's no point to make dump so large (and possibly cut by Kibana)\r\n       //\r\n       stack = `[0]: ${exception.errors[0].message} (${exception.errors.length - 1} more errors). ` + stack;\r\n    }\r\n    return stack ?? `(stack unknown: ${exception?.message})`;\r\n}\r\n\r\nfunction _log(s: string, severity: string) {\r\n    let now = new Date()\r\n    let ss = `${now.toISOString()} |${severity}| - ${s}`;\r\n    if (severity == 'E') {\r\n        console.error(ss);\r\n    } else {\r\n        console.info(ss);\r\n    }\r\n}\r\n "]}