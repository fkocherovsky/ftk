{"version":3,"file":"schema.js","sourceRoot":"","sources":["../../../../../gserver/src/core/schema.ts"],"names":[],"mappings":"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","sourcesContent":["// TODO: DECOR\r\n\r\nimport { isString, isArray, toNumber, toString, GError } from '../../../kit/src/core';\r\nimport { fromJson, Garray, Gmap, Gvalue, Index } from '../../../kit/src/core/types';\r\nimport { Utils } from '../../../kit/src/core/utils'\r\n\r\nexport type UserRole = string;\r\nexport type ServiceAccess = 'none' | 'internal' | 'unlimited' | 'public';\r\nexport type ServiceHandler = Function & { metadata: ServiceMetadata };\r\nexport type ServiceParamTypeName = 'boolean' | 'number' | 'string' | 'object' | 'boolean[]' | 'number[]' | 'string[]' | 'object[]';\r\nexport type ServiceResponseTypeName = 'null' | 'string' | 'xml' | 'object' | 'object[]';\r\nexport type ServiceResponseType = null | string | Gmap | Garray; // | Gxml\r\nexport type ServiceProtocol = 'http' | 'ws' | 'http-upload' | 'http-download';\r\nexport type ServiceMethod = 'GET' | 'POST' | 'PUT' | 'ANY';\r\nexport type ServiceFormat = 'json' | 'soap' | 'csv' | 'pdf' | 'raw';\r\nexport type ServiceAuthorization = 'none' | 'token' | 'basic' | 'soap';\r\nexport type ServiceAuthorizationCallback = () => { user: string; password: string; }; // currently, only used in 'basic' authorization\r\nexport type ServiceAuthorizationOptions = ServiceAuthorization | { type: Extract<ServiceAuthorization, 'basic' | 'soap'>; settingsFN: ServiceAuthorizationCallback; };\r\nexport type TokenValidationLevel = 'none' | 'never-expires' | 'full'; // 'none' is needed to have services where token is processed/validated if present, but it's optional for the service operation (authorization = 'none' is not the same), e.g. system/keepAlive\r\n\r\nconst SERVICE_FORMAT_METADATA: Index<{ contentType: string; responseTypes: ServiceResponseTypeName[] }> = {\r\n   'json'   : { contentType: 'application/json;charset=UTF-8' , responseTypes: ['null', 'object', 'object[]'] },\r\n   'soap'   : { contentType: 'application/soap+xml'           , responseTypes: ['null', 'xml']                },\r\n   'csv'    : { contentType: 'text/plain;charset=UTF-8'       , responseTypes: ['null', 'object', 'object[]'] },\r\n   'pdf'    : { contentType: 'application/pdf'                , responseTypes: ['null', 'string']             },\r\n   'raw'    : { contentType: null                             , responseTypes: ['null', 'string']             },\r\n   'default': { contentType: 'application/json;charset=UTF-8' , responseTypes: ['null']                       }\r\n};\r\n\r\nexport interface ServiceMetadata {\r\n\r\n    /** Service protocol (default is 'http') */\r\n    protocol?: ServiceProtocol;\r\n \r\n    /** Should only be used in schema-less services or when method = ANY is needed; in all other cases, this value is overridden by schema definition */\r\n    method?: ServiceMethod;\r\n \r\n    /** 'json' by default. The format for the outgoing non-stream serialization of the response (this sometimes affects how input is processed as well); note that for streamed responses, this is ignored as the streamed content is passed AS IS */\r\n    format?: ServiceFormat;\r\n \r\n    /** service authorization method, or a structure with authorization type and user/password-providing callback (authorization type default is 'soap' for SOAP services (format = 'soap'), 'token' for all others) */\r\n    authorization?: ServiceAuthorizationOptions;\r\n \r\n    /** 'full' (default) if a service requires session token validation (including expiration), 'never-expires' if expiration needn't be validated ('none' is reserved for internal system usages, do not use) */\r\n    tokenValidationLevel?: TokenValidationLevel;\r\n \r\n    /** false (default) if a service may not be called during login (specifically prior to password expiration validation), true otherwise (e.g. for login-related services) */\r\n    allowPasswordExpiredToken?: boolean;\r\n \r\n    /** if set to true, returns JSON response data AS IS without formatting it according to standard serialization structure (i.e. without 'success', 'results' etc.) */\r\n    preserveRawJsonResponse?: boolean;\r\n \r\n    /** specifies custom content-type for non-stream service response (typically combined with format = 'raw'); note that for streamed responses, this is ignored and a separate streaming-specific content-type/content-disposition logic is used */\r\n    rawContentType: string;\r\n \r\n    /** specifies custom content encoding for non-stream service response (typically combined with format = 'raw'); note that for streamed responses, this is ignored since streams are always passed AS IS, without altering encoding */\r\n    rawResponseEncoding: BufferEncoding;\r\n \r\n   /** timeout value if needs to override the one supplied by schema, or the one which is default (30 sec) */\r\n   timeout?: number;\r\n \r\n   /** prevents logging at service definition level (usable for services which should not be traffic-logged by design, e.g. ping/keepAlive and services responding with security-sensitive data */\r\n   noTrafficLog: boolean;\r\n}\r\n \r\nexport class ServiceDescriptor {\r\n\r\n   constructor(name: string, handler: ServiceHandler) {\r\n      this.name = name;\r\n      this.handler = handler;\r\n      this.schemaParams = null; // for typed (schema-taken) services - params are loaded later (when schema is loaded), for non-typed - this is left null so all params are passed unconverted\r\n\r\n      let md = handler.metadata;\r\n      this.protocol = md?.protocol ?? 'http';\r\n      this.method = md?.method ?? 'GET';\r\n      this.format = md?.format ?? 'json';\r\n      this.authorization = md?.authorization ?? (this.format == 'soap' ? 'soap' : 'token');\r\n      this.tokenValidationLevel = md?.tokenValidationLevel ?? 'full';\r\n      this.allowPasswordExpiredToken = md?.allowPasswordExpiredToken ?? false;\r\n      this.preserveRawJsonResponse = md?.preserveRawJsonResponse ?? false;\r\n      this.rawContentType = md?.rawContentType ?? null;\r\n      this.rawResponseEncoding = md?.rawResponseEncoding ?? null;\r\n      this.timeout = md?.timeout ?? null;\r\n      this.noTrafficLog = md?.noTrafficLog ?? false;\r\n\r\n      let namelow = name.toLowerCase();\r\n      if (namelow.startsWith('internal.')) { this.isInternalService = true; }\r\n      if (namelow.startsWith('services.system.')) { this.isSystemService = true; }\r\n      if (namelow.startsWith('services.testing.')) { this.isTestingService = true; }\r\n\r\n      this.access = this.isInternalService ? 'internal' : (this.isTestingService || this.isSystemService ? 'unlimited' : 'none');\r\n      this.isExposed = this.isSystemService || this.isInternalService || this.isTestingService ? true : false;\r\n      this.isBinary = this.format == 'pdf' || this.rawResponseEncoding == 'binary';\r\n\r\n      if (this.format == 'raw' && (!this.rawContentType || !this.rawResponseEncoding)) { throw new GError(`'raw' service format requires 'rawContentType' and 'rawResponseEncoding' to be explicitly specified in service metadata`); }\r\n   }\r\n\r\n   name: string;\r\n   handler: ServiceHandler;\r\n   schemaParams: ParamsDef;\r\n\r\n   protocol: ServiceProtocol;\r\n   method: ServiceMethod;\r\n   format: ServiceFormat;\r\n   access: ServiceAccess;\r\n   bindings: Index<string> = {};\r\n   permissions: { [key in UserRole]?: Permissions } = {};\r\n   authorization: ServiceAuthorizationOptions;\r\n   tokenValidationLevel: TokenValidationLevel;\r\n   allowPasswordExpiredToken: boolean;\r\n   preserveRawJsonResponse: boolean;\r\n   rawContentType: string;\r\n   rawResponseEncoding: BufferEncoding;\r\n   timeout: number;\r\n   noTrafficLog: boolean;\r\n\r\n   isInternalService = false;\r\n   isSystemService = false;\r\n   isTestingService = false;\r\n   isExposed = false;\r\n   isBinary = false;\r\n\r\n   get contentType()     { return this.rawContentType ?? (SERVICE_FORMAT_METADATA[this.format] || SERVICE_FORMAT_METADATA['default']).contentType; }\r\n   getResponseTypes()    { return (SERVICE_FORMAT_METADATA[this.format] || SERVICE_FORMAT_METADATA['default']).responseTypes; }\r\n   getResponseEncoding() { return this.rawResponseEncoding ?? (this.isBinary ? 'binary' : 'utf8'); }\r\n\r\n}\r\n\r\n\r\nexport class ParamsDef {\r\n\r\n   names?: string[];\r\n   types?: ServiceParamTypeName[];\r\n\r\n   constructor(names?: string[], types?: ServiceParamTypeName[]) {\r\n      this.names = names || [];\r\n      this.types = types || [];\r\n\r\n      this._index = {};\r\n      for (let i = 0, len = this.names.length; i < len; i++) {\r\n         this._index[this.names[i]] = i;\r\n      }\r\n   }\r\n\r\n   get size() { return this.names.length; }\r\n\r\n   set(i: number, name: string, type: ServiceParamTypeName) {\r\n      this.names[i] = name;\r\n      this.types[i] = type;\r\n      this._index[name] = i;\r\n   }\r\n\r\n   getType(name: string) {\r\n      let i = this._index[name];\r\n      return i == null ? null : this.types[i];\r\n   }\r\n\r\n   getIndex(name: string) {\r\n      let i = this._index[name];\r\n      return i == null ? -1 : i;\r\n   }\r\n\r\n   private _index: Index<number>;\r\n}\r\n\r\nexport function schemaParseParamValue(sd: ServiceDescriptor, name: string, s: string) {\r\n   let value: Gvalue = s;\r\n   let type: ServiceParamTypeName;\r\n   try {\r\n      type = sd.schemaParams && sd.schemaParams.getType(name) || null;\r\n      if (type != null) {\r\n         value = schemaParseTypedValue(type, value);\r\n      } else {\r\n         value = schemaParseUntypedValue(value);\r\n      }\r\n   } catch (e) {\r\n      // TODO: replace ${s} by ${logFormat(s)}, but first to implement formating\r\n      throw new GError(`Failed to convert param '${name}' with value '${s}' to '${type}' in service '${sd.name}'`, e);\r\n   }\r\n   return value;\r\n}\r\n\r\nexport function schemaParseTypedValue(type: ServiceParamTypeName, o: Gvalue) {\r\n   let value: Gvalue = o;\r\n   if (value === '' && type != 'string') { return null; }\r\n \r\n   switch (type) {\r\n      case 'boolean':\r\n         // NOTE: cannot use toBoolean because e.g. toBoolean('0', undefined) returns true\r\n         value = (o === true || o === 'true') ? true : ((o === false || o === 'false') ? false : undefined);\r\n         break;\r\n \r\n      case 'number':\r\n         value = toNumber(o, undefined);\r\n         break;\r\n \r\n      case 'string':\r\n         value = toString(value, undefined);\r\n         break;\r\n \r\n      case 'object':\r\n         if (Utils.isPlainObject(o)) {\r\n            value = o;\r\n         } else if (isString(o) && o.charAt(0) == '{' && o.charAt(o.length - 1) == '}') {\r\n            value = fromJson(o);\r\n         } else {\r\n            throw new Error(`Object parse failure: ${o}`);\r\n         }\r\n         break;\r\n \r\n      case 'boolean[]':\r\n      case 'number[]':\r\n      case 'string[]':\r\n      case 'object[]':\r\n         if (isArray(o)) {\r\n            value = o; // params=[value,value] (proper typed JSON primitives array)\r\n         } else if (isString(o)) {\r\n            let avalue: Gvalue[];\r\n            if (o.charAt(0) == '[' && o.charAt(o.length - 1) == ']') {\r\n               avalue = fromJson(o) as Gvalue[]; // params=value&params=value (note that values are strings in this case, since they're passed as query string params)\r\n            } else {\r\n               avalue = [ o ]; // params=value (1-item input comes as a single string, so it's converted to 1-item array of string first)\r\n            }\r\n             // type-checking (and typifying) primitive array items\r\n            if (type == 'string[]') {\r\n               value = avalue as Garray; // target is string[] and source is params=value&params=value, i.e. string[]\r\n            } else if (!isString(avalue[0])) {\r\n               value = avalue as Garray; // target is JSON primitive array (of any item type) and source was params='[value,value]' parsed into JSON primitive array by the above code\r\n            } else {\r\n                // target is not string[] and source is string[] (in params=value&params=value, query string values are always strings, so we should cast each array item (string) to the target primitive array item type)\r\n               let atype = type.replace(/\\W/g, '') as ServiceParamTypeName;\r\n               value = (avalue as []).map(x => schemaParseTypedValue(atype, x)) as Garray;\r\n            }\r\n         } else {\r\n            throw new Error(`Array parse failure: ${o}`);\r\n         }\r\n         break;\r\n   }\r\n   return value;\r\n}\r\n\r\nexport function schemaParseUntypedValue(o: Gvalue) {\r\n   let value: Gvalue = o;\r\n   if (isString(o)) {\r\n      if (o.charAt(0) == '[' && o.charAt(o.length - 1) == ']') {\r\n         value = JSON.parse(o);\r\n      } else if (o.charAt(0) == '{' && o.charAt(o.length - 1) == '}') {\r\n         value = JSON.parse(o);\r\n      }\r\n   }\r\n   return value;\r\n}\r\n\r\n\r\n"]}