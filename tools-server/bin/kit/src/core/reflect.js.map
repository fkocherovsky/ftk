{"version":3,"file":"reflect.js","sourceRoot":"","sources":["../../../../../kit/src/core/reflect.ts"],"names":[],"mappings":";;;AACA,SAAgB,QAAQ,CAAC,KAAU;IAC/B,OAAO,OAAO,KAAK,KAAK,QAAQ,CAAC;AACrC,CAAC;AAFD,4BAEC;AAGD,SAAgB,SAAS,CAAC,KAAU;IAChC,OAAO,OAAO,KAAK,KAAK,SAAS,CAAC;AACtC,CAAC;AAFD,8BAEC;AAOD,SAAgB,QAAQ,CAAC,KAAU;IAC/B,OAAO,CAAC,OAAO,KAAK,IAAI,QAAQ,CAAC,IAAI,QAAQ,CAAC,KAAK,CAAC,CAAC;AACzD,CAAC;AAFD,4BAEC;AAGU,QAAA,OAAO,GAA4C,KAAK,CAAC,OAAO,CAAC;AAqB5E,SAAgB,OAAO,CAAC,KAAU;IAC/B,OAAO,CAAC,KAAK,IAAI,IAAI,IAAI,KAAK,KAAK,EAAE,IAAI,KAAK,KAAK,KAAK,CAAC,CAAC;AAC7D,CAAC;AAFD,0BAEC;AAED,SAAgB,UAAU,CAAC,KAAU;IAClC,OAAO,OAAO,KAAK,KAAK,UAAU,CAAC;AACtC,CAAC;AAFD,gCAEC;AAGD,SAAgB,UAAU,CAAC,QAAa,EAAE,UAAe;IACtD,OAAO,UAAU,IAAI,UAAU,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,IAAI,UAAU,IAAI,QAAQ,CAAC,SAAS,YAAY,UAAU,CAAC,IAAI,KAAK,CAAC;AAC9H,CAAC;AAFD,gCAEC;AAcD,SAAgB,OAAO,CAAC,GAAQ;IAC7B,IAAI,GAAG,GAAG,CAAC,CAAM,EAAE,EAAE,CAAC,CAAC,IAAI,CAAC,CAAC,WAAW,IAAI,CAAC,CAAC,WAAW,CAAC,QAAQ,IAAI,CAAC,CAAC,WAAW,CAAC,QAAQ,EAAE,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,CAAC;IACvH,IAAI,GAAG,IAAI,IAAI,EAAE;QAAE,OAAO,KAAK,CAAC;KAAE;IAClC,IAAI,GAAG,CAAC,SAAS,KAAK,SAAS,EAAE;QAAE,OAAO,GAAG,CAAC,GAAG,CAAC,KAAK,OAAO,CAAC;KAAE;IACjE,OAAO,GAAG,CAAC,GAAG,CAAC,SAAS,CAAC,KAAK,OAAO,IAAI,GAAG,CAAC,GAAG,CAAC,KAAK,OAAO,CAAC;AACjE,CAAC;AALD,0BAKC;AAaD,SAAgB,QAAQ,CAAC,KAAU,EAAE,QAAiB;IAClD,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,KAAK,EAAE,EAAE;QAChC,IAAI,IAAI,GAAG,OAAO,KAAK,CAAC;QAGxB,IAAI,IAAI,IAAI,QAAQ,EAAE;YAKnB,IAAI,KAAK,YAAY,IAAI,EAAE;gBACxB,OAAO,KAAK,CAAC,OAAO,EAAE,CAAC;aACzB;SACH;QAGD,IAAI,IAAI,IAAI,QAAQ,EAAE;YACnB,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,oBAAoB,EAAE,EAAE,CAAC,CAAC;SAClD;QAGD,KAAK,GAAG,CAAC,KAAK,CAAC;QAGf,IAAI,KAAK,KAAK,KAAK,EAAE;YAClB,OAAO,KAAK,CAAC;SACf;KACH;IACD,OAAO,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAChD,CAAC;AA7BF,4BA6BE;AACD,MAAM,oBAAoB,GAAG,KAAK,CAAC;AASpC,SAAgB,QAAQ,CAAC,KAAU,EAAE,QAAiB;IACnD,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,KAAK,EAAE,EAAE;QAChC,OAAO,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;KAChD;SAAM,IAAI,OAAO,KAAK,IAAI,QAAQ,EAAE;QAClC,OAAO,KAAK,CAAC;KACf;SAAM;QACJ,OAAO,KAAK,CAAC,QAAQ,EAAE,CAAC;KAC1B;AACJ,CAAC;AARD,4BAQC;AAaD,SAAgB,WAAW,CAAI,IAAsB,EAAE,GAAG,IAAW;IAClE,IAAI,QAAQ,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;IAG7C,QAAQ,GAAG,OAAO,CAAC,SAAS,CAAC,QAAQ,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;IAKzD,OAAO,QAAa,CAAC;AACxB,CAAC;AAVD,kCAUC","sourcesContent":["///////// isXXX\r\nexport function isString(value: any): value is string {\r\n    return typeof value === 'string';\r\n}\r\n\r\n/** Checks whether a given value is a boolean. */\r\nexport function isBoolean(value: any): value is boolean {\r\n    return typeof value === 'boolean';\r\n}\r\n\r\n/**\r\n * Checks whether a given value is a valid and finite number.\r\n *\r\n * Note: this function avoids implicit casts, unlike the builtin _isFinite_ function which will return true for values like '123', true, [], etc.\r\n */\r\nexport function isNumber(value: any): value is number {\r\n    return (typeof value == 'number') && isFinite(value);\r\n}\r\n\r\n/** Checks whether a given value is a native Array<T>. */\r\nexport let isArray: (<T = any>(value: any) => value is T[]) = Array.isArray;\r\n\r\n// /** Checks whether a given value is an array-like collection, such as an array, a typed array, an arguments list, a dom nodes list, etc. */\r\n// export function isArrayLike<T = any>(value: any): value is ArrayLike<T> {\r\n//    // fast check the most common cases\r\n//    if (isArray(value)) return true;\r\n//    if (isEmpty(value)) return false;\r\n\r\n//    // NOTE: according to the standard any object that has numeric index property access and a numeric length is\r\n//    // an `ArrayLike` object. However, there is no way to check that without iterating over the array items.\r\n//    // So instead we check for the well-known ArrayLike objects by their specific type name.\r\n//    if (isLike(typeName(value), ARRAY_LIKE_RE)) return true;\r\n\r\n//    // typed arrays are also array-like\r\n//    if (isTypedArray(value)) return true;\r\n\r\n//    return false;\r\n// }\r\n// const ARRAY_LIKE_RE = /Array|Arguments|HTMLCollection|NodeList|NamedNodeMap/;\r\n\r\n/** Checks whether a given value is an empty scalar value (i.e. either `null`, `undefined`, `NaN`, or empty string `\"\"`). */\r\nexport function isEmpty(value: any): boolean {\r\n   return (value == null || value === '' || value !== value);\r\n}\r\n\r\nexport function isFunction(value: any): value is Function {\r\n   return typeof value === 'function';\r\n}\r\n\r\n/** Checks whether a sub-class is derived (or equal to) a super-class. */\r\nexport function isSubClass(subclass: any, superclass: any): boolean {\r\n   return superclass && isFunction(subclass) && (subclass == superclass || subclass.prototype instanceof superclass) || false;\r\n}\r\n\r\n// declare interface PlainObject {\r\n//    /** The object lookup index. Returns the item with the specified index key, or `undefined` if not found. */\r\n//    [key: string]: any;\r\n\r\n// }\r\n\r\n// /** Checks whether a given value is a JavaScript object, which can be either a plain object (see `PlainObject`) or any other constructed object (such as a DOM node, a Date object, a RegExp object, an Array, etc.). */\r\n// export function isObject(value: any): value is Object & PlainObject {\r\n//    return (value != null && typeof value === 'object');\r\n// }\r\n\r\n\r\nexport function isClass(obj: any) {\r\n   let str = (s: any) => s && s.constructor && s.constructor.toString && s.constructor.toString().substring(0, 5) || null;\r\n   if (obj == null) { return false; }\r\n   if (obj.prototype === undefined) { return str(obj) === 'class'; }\r\n   return str(obj.prototype) === 'class' || str(obj) === 'class';\r\n}\r\n\r\n///////// toXXX\r\n\r\n/**\r\n * Casts a value to a floating-point number.\r\n *\r\n * Note: This method is not locale-aware. For the localized version of this method, use `lang.parseNumber`.\r\n *\r\n * @param value      The value to convert.\r\n * @param fallback   Fallback value to return in case the value is missing or cannot be converted to a number.\r\n * @return           The converted number.\r\n */\r\nexport function toNumber(value: any, fallback?: number): number {\r\n    if (value != null && value !== '') {\r\n       let type = typeof value;\r\n \r\n       // if value is temporal, return internal timestamp\r\n       if (type == 'object') {\r\n        // TODO: to define DateTime type\r\n        //   if (value instanceof DateTime) {\r\n        //      return value.time;\r\n        //   }\r\n          if (value instanceof Date) {\r\n             return value.getTime();\r\n          }\r\n       }\r\n \r\n       // if value is a string, remove thousands separator\r\n       if (type == 'string') {\r\n          value = value.replace(NUMERIC_THOUSANDS_RE, '');\r\n       }\r\n \r\n       // coerce to number\r\n       value = +value;\r\n \r\n       // check that value is not NaN\r\n       if (value === value) {\r\n          return value;\r\n       }\r\n    }\r\n    return (arguments.length > 1 ? fallback : 0);\r\n }\r\n const NUMERIC_THOUSANDS_RE = /\\,/g;\r\n\r\n /**\r\n * Casts a given value to a string value using the default converter.\r\n *\r\n * @param value      The value to convert.\r\n * @param fallback   Fallback value to return in case the value is missing.\r\n * @return           The converted string.\r\n */\r\nexport function toString(value: any, fallback?: string): string {\r\n   if (value == null || value === '') {\r\n      return (arguments.length > 1 ? fallback : '');\r\n   } else if (typeof value == 'string') {\r\n      return value;\r\n   } else {\r\n      return value.toString();\r\n   }\r\n}\r\n\r\n\r\n//////////////\r\n\r\n/**\r\n * Instantiates an object instance of a specified type.\r\n *\r\n * @template T   The type of object to create.\r\n * @param type   The type constructor.\r\n * @param args   Arguments to pass to the type constructor.\r\n * @return       The new object instance.\r\n */\r\nexport function instantiate<T>(type: ConstructorOf<T>, ...args: any[]): T {\r\n   let instance = Object.create(type.prototype);\r\n\r\n   // ES6: version\r\n   instance = Reflect.construct(instance.constructor, args);\r\n\r\n   // ES5: version\r\n   // instance.constructor.apply(instance, args);\r\n\r\n   return instance as T;\r\n}\r\n\r\n//////////////\r\n\r\n// /** Checks whether a given value is a non-blank string (i.e., contains at least one non-whitespace character). */\r\n// export function notBlank(value: any): value is string {\r\n//    return typeof value === 'string' && value.length > 0 && NOT_BLANK_RE.test(value);\r\n// }\r\n// const NOT_BLANK_RE = /\\S/;\r\n\r\n// /**\r\n//  * Gets the proper type name of a given value.\r\n//  * Use this method instead of the `typeof` operator to get a meaningful result.\r\n//  *\r\n//  * @param  value    The value whose type name to get.\r\n//  * @return          The type name (e.g., Number, String, Array, Function, etc.).\r\n//  */\r\n// export function typeName(value: any): string {\r\n//    // use Object.prototype.toString to extract a better type name than what is returned by typeof operator\r\n//    let name = NATIVE_TYPEOF.call(value).slice(8, -1);\r\n//    if (name == 'Object' && isFunction(value.constructor) && notBlank(value.constructor.name)) {\r\n//       // look for more specific type name through the object constructor\r\n//       return value.constructor.name;\r\n//    }\r\n//    if (name == 'Function' && notBlank(value.name)) {\r\n//       // look for more specific type name assuming the function is the type constructor\r\n//       return value.name;\r\n//    }\r\n//    return name;\r\n// }\r\n\r\n/////////////////////////\r\n\r\n// const OBJECT_PROTO = Object.prototype;\r\n// const NATIVE_TYPEOF = OBJECT_PROTO.toString;\r\n// const NATIVE_HASOWN = OBJECT_PROTO.hasOwnProperty;\r\n\r\n\r\n "]}