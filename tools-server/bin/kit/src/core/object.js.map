{"version":3,"file":"object.js","sourceRoot":"","sources":["../../../../../kit/src/core/object.ts"],"names":[],"mappings":"","sourcesContent":["// import { identityFN } from \"./function\";\r\n// import { isArray, isObject } from \"./reflect\";\r\n// import { Index } from \"./types\";\r\n\r\n// /**\r\n//  * Clones an object instance by creating a deep copy of its members.\r\n//  *\r\n//  * This method creates a deep clone, meaning that the given object, and all the objects that it contains, will be\r\n//  * recursively cloned. To perform a shallow clone, use the `clone` method.\r\n//  *\r\n//  * @template T   The type of object to clone.\r\n//  * @param value  The object instance to deep clone.\r\n//  * @return       The deeply cloned instance.\r\n//  */\r\n// export function cloneDeep<T>(value: T): T {\r\n//     if (value == null || typeof value != 'object') return value;\r\n//     let deep = arguments[1] !== false;\r\n//     let innerClone = deep ? (v: any) => cloneDeep.call(null, v, true, depth + 1) : identityFN;\r\n \r\n//     // fast check for cyclic references\r\n//     let depth = (arguments.length > 2 ? arguments[2] : 0);\r\n//     if (depth > 50) {\r\n//         // TODO: logger\r\n//         console.log('Cloning operation exceeded maximum depth.');\r\n//         return null;\r\n//     }\r\n \r\n//     // array-like objects\r\n//     if (isArrayLike(value)) {\r\n//        if (isArray(value)) {\r\n//           // plain array\r\n//           return deep ? value.map(innerClone) : value.slice() as any;\r\n//        } else if (isTypedArray(value)) {\r\n//           // typed array\r\n//           return value.slice() as any;\r\n//        } else {\r\n//           // array-like: Arguments|HTMLCollection|NodeList|NamedNodeMap\r\n//           throw Error(`Cannot clone a '${typeName(value)}' object`);\r\n//        }\r\n//     }\r\n \r\n//     let obj1 = value as any;\r\n//     let obj2: any;\r\n \r\n//     // cloneable objects (e.g., Color, DateTime, GeoPoint, or any object implementing CLONE_OP method)\r\n//     if (CLONE_OP in obj1) {\r\n//        return obj1[CLONE_OP]();\r\n//     }\r\n \r\n//     // plain objects\r\n//     if (isPlainObject(obj1)) {\r\n//        obj2 = (Object.getPrototypeOf(obj1) == null) ? Object.create(null) : {};\r\n//        for (let k in obj1) {\r\n//           if (NATIVE_HASOWN.call(obj1, k)) {\r\n//              obj2[k] = innerClone(obj1[k]);\r\n//           }\r\n//        }\r\n//        return obj2;\r\n//     }\r\n \r\n//     // builtin Date object\r\n//     if (isDate(obj1)) {\r\n//        return new Date(obj1.getTime()) as any;\r\n//     }\r\n \r\n//     // // builtin RegeExp object\r\n//     // if (isRegExp(obj1)) {\r\n//     //    return cloneRegex(obj1) as any;\r\n//     // }\r\n \r\n//     // builtin Map object\r\n//     if (isMap(obj1)) {\r\n//        obj2 = new Map();\r\n//        obj1.forEach((v, k) => obj2.set(k, innerClone(v)));\r\n//        return obj2;\r\n//     }\r\n \r\n//     // builtin Set object\r\n//     if (isSet(obj1)) {\r\n//        obj2 = new Set();\r\n//        obj1.forEach(v => obj2.add(innerClone(v)));\r\n//        return obj2;\r\n//     }\r\n \r\n//     // throw exception to avoid bogus cloning of non-plain objects\r\n//     throw Error(`Cannot clone a '${typeName(value)}' object`);\r\n \r\n//  }\r\n \r\n\r\n// /**\r\n//  * Merges one or more objects into a single object.\r\n//  *\r\n//  * This method performs a deep merge, meaning that the given objects will be memberwise merged, and any objects that they contain\r\n//  * will be in turn recursively merged. To perform a shallow merge, use the `mergeObj` method.\r\n//  *\r\n//  * @template T  The type of objects to merge.\r\n//  * @param args  The objects to merge in order of precedence (i.e., each object overrides the ones preceding it).\r\n//  * @return      The deeply merged object\r\n//  */\r\n// export function mergeDeep<T>(...args: T[]): T {\r\n//     (args as Array<any>).push(true);\r\n//     return mergeObj.apply(null, args);\r\n//  }\r\n \r\n//  /**\r\n//  * Merges one or more objects into a single object.\r\n//  *\r\n//  * The objects are merged in the order they are listed (i.e., each object overrides the ones preceding it).\r\n//  *\r\n//  * This method performs a shallow merge, meaning that the given objects will be memberwise merged, but any objects that they contain\r\n//  * will remain as the original copy. To perform a deep merge, use the `mergeDeep` method.\r\n//  *\r\n//  * @template T  The type of objects to merge.\r\n//  * @param args  The objects to merge.\r\n//  * @return      The merged object.\r\n//  */\r\n// export function mergeObj<T>(...args: T[]): T {\r\n//     let result: Index<any> = {};\r\n \r\n//     let nargs = arguments.length;\r\n//     let isDeep = false;\r\n//     if (nargs > 0 && typeof arguments[nargs - 1] == 'boolean') {\r\n//        isDeep = arguments[nargs - 1];\r\n//        nargs--;\r\n//     }\r\n \r\n//     for (let i = 0; i < nargs; i++) {\r\n//        let source = arguments[i];\r\n//        if (!isObject(source)) continue;\r\n//        for (let k in source) {\r\n//           if (!NATIVE_HASOWN.call(source, k)) continue;\r\n//           let value = source[k];\r\n//           if (isDeep) {\r\n//              if (isObject(value) && !isArray(value)) {\r\n//                 result[k] = mergeDeep(result[k], value);\r\n//              } else {\r\n//                 result[k] = cloneDeep(value);\r\n//              }\r\n//           } else {\r\n//              result[k] = value;\r\n//           }\r\n//        }\r\n//     }\r\n//     return result as T;\r\n//  }\r\n \r\n\r\n//  /////////////////////////////////\r\n\r\n//  const NATIVE_HASOWN = Object.prototype.hasOwnProperty;"]}